package Package;
/*
抽象类:含有抽象方法的类
抽象方法:子类共性方法抽取到父类后,不能确定每个子类执行该方法时显示什么内容,这时就要把该方法写为抽象方法,强制子类重写
                           public abstract void 方法名();
       有抽象方法时类也要遵守格式 public abstract 类名{}
       抽象类不能用于实例化,但其子类不是抽象类就可以
 */
/*
接口:一种规则/行为的抽象
定义接口:public interface 接口名{}
使用接口:接口和类之间是实现关系 public class 类名 extends 父类 implements 接口1,接口2{}
接口不能多态调用,要用所在类的类型调用
接口内的成员变量都用public static final修饰     无构造方法
多个接口中有重名的方法只需重写一次就可以了
特殊情况:如果使用的接口继承了几个接口,需要在使用接口的类中重写所有的抽象方法

接口升级时需要在接口中添加新的方法但是使用接口的类要重写抽象方法不然会报错
为了避免这种情况,jdk8之后接口可以创建带有方法体的方法,也就是不会被强制重写的默认方法:public default void 方法名(){}
但是!如果多个接口有相同的默认方法同时被使用,就必须重写

jdk8之后接口中也可以有静态方法:psv 方法名(){}
静态方法不能重写!
静态方法只能通过接口名进行调用

jdk9之后接口内有私有方法,只服务于接口内部

如果一个方法中的形参为一个确定的接口,那么所有调用这个接口的类都可以作为这个方法的形参

设计模式:解决各种问题的套路
适配器设计模式:解决接口与实现类之间的矛盾问题
具体实现步骤:先将接口接入适配器,再用子类继承适配器,之后就可以用哪个方法重写哪个方法,适配器也设成抽象类
 */
public class Instruction1 {
}
